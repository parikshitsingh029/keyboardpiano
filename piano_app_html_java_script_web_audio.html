<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Parikshit's Web Piano • JS + Web Audio</title>
  <style>
    :root {
      --bg: #0b1020;
      --panel: #121931;
      --text: #e9eefb;
      --muted: #9fb0d3;
      --accent: #7aa2ff;
      --whiteKey: #f7f9ff;
      --whiteKeyEdge: #d8deee;
      --whiteKeyActive: #cfe1ff;
      --blackKey: #111319;
      --blackKeyTop: #222733;
      --blackKeyActive: #3a4a6e;
      --danger: #ff6b6b;
      --success: #0ecb81;
      --warn: #ffd166;
    }
    * { box-sizing: border-box; }
    html, body { height: 100%; }
    body {
      margin: 0; font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Ubuntu, Cantarell, "Helvetica Neue", Arial;
      background: linear-gradient(180deg, #0b1020 0%, #0f1430 100%);
      color: var(--text);
      display: grid; place-items: center;
      padding: 24px;
    }
    .app {
      width: min(1100px, 95vw);
      background: linear-gradient(180deg, #121931 0%, #0f1530 100%);
      border: 1px solid #2a3557;
      border-radius: 18px;
      box-shadow: 0 10px 40px rgba(0,0,0,.35), inset 0 1px 0 rgba(255,255,255,.06);
      overflow: hidden;
    }
    header { display:flex; align-items:center; justify-content:space-between; padding: 18px 22px; border-bottom: 1px solid #202a48; }
    h1 { font-size: 18px; margin: 0; letter-spacing: .3px; color: var(--text); }
    .muted { color: var(--muted); font-size: 12px; }

    .controls { display: grid; grid-template-columns: repeat(6, minmax(0,1fr)); gap: 12px; padding: 16px 22px; }
    .control {
      background: #0e1430;
      border: 1px solid #203058;
      border-radius: 12px; padding: 10px 12px; display:flex; flex-direction:column; gap: 8px;
    }
    .control label { font-size: 12px; color: var(--muted); }
    .control input[type="range"] { width: 100%; }
    .row { display:flex; align-items:center; gap:8px; flex-wrap:wrap; }
    select, button, input[type="checkbox"], input[type="range"] {
      accent-color: var(--accent);
    }
    select, button { 
      background: #121a3b; color: var(--text); border: 1px solid #2f3b63; border-radius: 10px; padding: 8px 10px; 
      font: inherit; cursor: pointer; 
    }
    button:disabled { opacity: .55; cursor:not-allowed; }
    .btn-danger { border-color: #7a2b2b; background: #2a1212; color:#ffb3b3; }
    .btn-outline { background: transparent; }

    .piano-wrap { position: relative; height: 300px; padding: 18px 22px 26px; }
    .piano { position: relative; height: 100%; user-select: none; -webkit-user-select: none; }

    /* White keys */
    .white-keys { position: absolute; inset: 0; display: grid; grid-template-columns: repeat(var(--white-count), 1fr); gap: 0; }
    .white-key {
      position: relative; border: 1px solid var(--whiteKeyEdge); border-bottom-width: 3px; background: linear-gradient(#ffffff, #f2f5ff);
      border-radius: 0 0 10px 10px; margin: 0 -0.5px; /* overlap borders */
      display: flex; align-items: flex-end; justify-content: center; padding-bottom: 8px; color: #2a3353; font-size: 12px; letter-spacing:.3px;
      transition: transform .02s ease, background .12s ease;
    }
    .white-key.active { background: linear-gradient(#e9f1ff, #cfe1ff); transform: translateY(1px); border-bottom-width: 2px; }

    /* Black keys */
    .black-keys { position: absolute; inset: 0; pointer-events: none; }
    .black-key { position: absolute; width: var(--black-w); height: 58%; left: 0; top: 0; transform: translateX(-50%);
      background: linear-gradient(180deg, var(--blackKeyTop), var(--blackKey)); border: 1px solid #2a3557; border-bottom-width: 3px; border-radius: 0 0 8px 8px; 
      box-shadow: 0 6px 18px rgba(0,0,0,.55);
      display: flex; align-items: flex-end; justify-content: center; padding-bottom: 6px; color: #d4dbf5; font-size: 11px;
      pointer-events: auto;
      transition: transform .02s ease, background .12s ease;
    }
    .black-key.active { background: linear-gradient(180deg, #2e3850, #141a28); transform: translate(-50%, 1px); border-bottom-width: 2px; }

    footer { padding: 10px 22px 18px; display:flex; align-items:center; justify-content:space-between; border-top: 1px solid #202a48; }
    .kbd-help { font-size: 12px; color: var(--muted); }
    .pill { display:inline-flex; align-items:center; gap:6px; padding:4px 8px; border:1px solid #2a3557; background:#111733; border-radius:999px; }
    .dot { width:8px; height:8px; border-radius:50%; background: var(--success); box-shadow:0 0 8px var(--success); }
    .dot.off { background:#7b869f; box-shadow:none; }

    @media (max-width: 820px) {
      .controls { grid-template-columns: repeat(2, minmax(0,1fr)); }
    }
  </style>
</head>
<body>
  <div class="app">
    <header>
      <h1>Web Piano <span class="muted">• JavaScript + Web Audio API</span></h1>
      <div class="pill"><span class="dot off" id="audioDot"></span><span class="muted">Audio Context</span></div>
    </header>

    <section class="controls">
      <div class="control">
        <label for="wave">Waveform</label>
        <select id="wave">
          <option value="sine">Sine</option>
          <option value="triangle" selected>Triangle</option>
          <option value="sawtooth">Sawtooth</option>
          <option value="square">Square</option>
        </select>
      </div>
      <div class="control">
        <label for="volume">Volume</label>
        <input id="volume" type="range" min="0" max="1" step="0.01" value="0.7" />
      </div>
      <div class="control">
        <label for="octave">Octave (start C)</label>
        <select id="octave">
          <option value="3">C3</option>
          <option value="4" selected>C4 (Middle C)</option>
          <option value="5">C5</option>
        </select>
      </div>
      <div class="control">
        <label>Sustain</label>
        <div class="row"><input id="sustain" type="checkbox" /> <span class="muted">Hold notes after keyup</span></div>
      </div>
      <div class="control">
        <label>Record</label>
        <div class="row">
          <button id="recBtn">● Record</button>
          <button id="stopBtn" disabled>■ Stop</button>
        </div>
      </div>
      <div class="control">
        <label>Playback</label>
        <div class="row">
          <button id="playBtn" disabled>▶ Play</button>
          <button id="clearBtn" class="btn-outline" disabled>Clear</button>
        </div>
      </div>
    </section>

    <section class="piano-wrap">
      <div id="piano" class="piano">
        <div class="white-keys" id="whiteKeys" style="--white-count:14"></div>
        <div class="black-keys" id="blackKeys"></div>
      </div>
    </section>

    <footer>
      <div class="kbd-help">Keyboard: <code>z s x d c v g b h n j m , q 2 w 3 e r 5 t 6 y 7</code> (≈ two octaves from selected C)</div>
      <div class="muted">Made with ❤️ using Web Audio</div>
    </footer>
  </div>

  <script>
    // ---------- Utilities ----------
    const noteNames = ["C","C#","D","D#","E","F","F#","G","G#","A","A#","B"]; 
    const midiToFreq = (midi) => 440 * Math.pow(2, (midi - 69) / 12);
    const midiToName = (midi) => {
      const name = noteNames[midi % 12];
      const octave = Math.floor(midi / 12) - 1;
      return name + octave;
    };

    // 24-key keyboard mapping (chromatic order)
    const KEY_ORDER = ['z','s','x','d','c','v','g','b','h','n','j','m',',','q','2','w','3','e','r','5','t','6','y','7'];
    const PRESSED = new Set();

    // ---------- Audio Engine ----------
    let audioCtx = null;
    let masterGain = null;
    const activeVoices = new Map(); // midi -> {osc1, osc2, gain, filter}
    const sustained = new Set();

    const getCtx = () => {
      if (!audioCtx) {
        audioCtx = new (window.AudioContext || window.webkitAudioContext)();
        masterGain = audioCtx.createGain();
        masterGain.gain.value = parseFloat(volume.value);
        masterGain.connect(audioCtx.destination);
        document.getElementById('audioDot').classList.remove('off');
      }
      return audioCtx;
    };

    function voiceOn(midi, velocity = 1) {
      getCtx();
      if (activeVoices.has(midi)) return; // prevent duplicates

      const now = audioCtx.currentTime;
      const freq = midiToFreq(midi);

      const osc1 = audioCtx.createOscillator();
      const osc2 = audioCtx.createOscillator();
      const gain = audioCtx.createGain();
      const filter = audioCtx.createBiquadFilter();

      osc1.type = wave.value;
      osc2.type = wave.value;
      osc1.frequency.value = freq;
      osc2.frequency.value = freq * 1.005; // slight detune for richness

      filter.type = 'lowpass';
      filter.frequency.setValueAtTime(9000, now);
      filter.Q.value = 0.5;

      osc1.connect(filter);
      osc2.connect(filter);
      filter.connect(gain);
      gain.connect(masterGain);

      // ADSR envelope (piano-like)
      const A = 0.01, D = 0.2, S = 0.65, R = 0.6;
      const peak = Math.max(0.0001, velocity) * 0.9;
      gain.gain.cancelScheduledValues(now);
      gain.gain.setValueAtTime(0.0001, now);
      gain.gain.linearRampToValueAtTime(peak, now + A);
      gain.gain.linearRampToValueAtTime(peak * S, now + A + D);

      osc1.start(now);
      osc2.start(now);

      activeVoices.set(midi, { osc1, osc2, gain, filter, release: R, startedAt: now });
    }

    function voiceOff(midi) {
      if (!audioCtx) return;
      const v = activeVoices.get(midi);
      if (!v) return;
      if (sustain.checked) { sustained.add(midi); return; }
      const now = audioCtx.currentTime;
      const R = v.release;
      v.gain.gain.cancelScheduledValues(now);
      v.gain.gain.setValueAtTime(v.gain.gain.value, now);
      v.gain.gain.linearRampToValueAtTime(0.0001, now + R);
      v.osc1.stop(now + R + 0.02);
      v.osc2.stop(now + R + 0.02);
      setTimeout(() => activeVoices.delete(midi), (R+0.03)*1000);
    }

    function flushSustain() {
      if (!audioCtx) return;
      const toRelease = Array.from(sustained);
      sustained.clear();
      toRelease.forEach(voiceOff);
    }

    // ---------- UI Piano Generation ----------
    const whiteKeysEl = document.getElementById('whiteKeys');
    const blackKeysEl = document.getElementById('blackKeys');
    const wave = document.getElementById('wave');
    const volume = document.getElementById('volume');
    const octaveSel = document.getElementById('octave');
    const sustain = document.getElementById('sustain');
    const recBtn = document.getElementById('recBtn');
    const stopBtn = document.getElementById('stopBtn');
    const playBtn = document.getElementById('playBtn');
    const clearBtn = document.getElementById('clearBtn');

    let startC = 60; // C4 default
    let displayedMidis = []; // 24 chromatic notes from start C

    function buildKeyboard() {
      whiteKeysEl.style.setProperty('--white-count', 14);
      const whitePattern = [0,2,4,5,7,9,11]; // within an octave starting from C
      const blackAfterWhiteIdx = [0,1,3,4,5]; // black keys after these white indices (per 7)

      whiteKeysEl.innerHTML = '';
      blackKeysEl.innerHTML = '';
      displayedMidis = [];

      const whitePerOct = 7;
      const octaves = 2;
      const totalWhite = whitePerOct * octaves; // 14
      const whiteWidthPct = 100 / totalWhite;
      const blackWidthPct = whiteWidthPct * 0.6;
      blackKeysEl.style.setProperty('--black-w', blackWidthPct + '%');

      // Build white keys (C..B over two octaves)
      for (let w = 0; w < totalWhite; w++) {
        const octaveOffset = Math.floor(w / whitePerOct);
        const idxInOct = w % whitePerOct; // 0..6
        const semitoneInOct = whitePattern[idxInOct];
        const midi = startC + octaveOffset * 12 + semitoneInOct;
        displayedMidis.push(midi);

        const k = document.createElement('div');
        k.className = 'white-key';
        k.dataset.midi = midi;
        k.title = `${midiToName(midi)}\nKey: ${keyForMidi(midi) ?? '—'}`;
        k.innerHTML = `<span>${midiToName(midi)}</span>`;
        attachKeyPointer(k, midi, true);
        whiteKeysEl.appendChild(k);

        // Insert the black key that sits AFTER certain white keys (except where E-B gap)
        const idxInPattern = idxInOct % whitePerOct;
        const shouldBlack = blackAfterWhiteIdx.includes(idxInPattern);
        if (shouldBlack) {
          const blackMidi = midi + 1;
          displayedMidis.push(blackMidi);
          const b = document.createElement('div');
          b.className = 'black-key';
          b.dataset.midi = blackMidi;
          b.title = `${midiToName(blackMidi)}\nKey: ${keyForMidi(blackMidi) ?? '—'}`;
          b.style.left = ((w + 1) * whiteWidthPct) + '%';
          attachKeyPointer(b, blackMidi, false);
          blackKeysEl.appendChild(b);
        }
      }

      // Sort displayedMidis to strict increasing order and keep only first 24 chromatic from startC
      const full = [];
      for (let i = 0; i < 24; i++) full.push(startC + i);
      displayedMidis = full;
    }

    function attachKeyPointer(el, midi, isWhite) {
      const down = (e) => {
        e.preventDefault(); el.setPointerCapture?.(e.pointerId);
        el.classList.add('active');
        voiceOn(midi, 1);
        addToRecording('on', midi);
      };
      const up = (e) => {
        e.preventDefault();
        el.classList.remove('active');
        voiceOff(midi);
        addToRecording('off', midi);
      };
      el.addEventListener('pointerdown', down);
      el.addEventListener('pointerup', up);
      el.addEventListener('pointercancel', up);
      el.addEventListener('pointerleave', (e)=>{
        if (el.classList.contains('active')) up(e);
      });
    }

    // Map 24 chromatic notes starting from startC to KEY_ORDER
    function keyForMidi(midi) {
      const idx = midi - startC;
      if (idx < 0 || idx >= KEY_ORDER.length) return null;
      return KEY_ORDER[idx];
    }

    function midiForKey(key) {
      const idx = KEY_ORDER.indexOf(key.toLowerCase());
      if (idx === -1) return null;
      return startC + idx;
    }

    // Keyboard handlers
    window.addEventListener('keydown', (e) => {
      if (e.repeat) return; // ignore auto-repeat
      const midi = midiForKey(e.key);
      if (midi == null) return;
      PRESSED.add(e.key.toLowerCase());
      // highlight DOM key
      highlightKey(midi, true);
      voiceOn(midi, 1);
      addToRecording('on', midi);
    });
    window.addEventListener('keyup', (e) => {
      const k = e.key.toLowerCase();
      if (!PRESSED.has(k)) return;
      PRESSED.delete(k);
      const midi = midiForKey(k);
      if (midi == null) return;
      highlightKey(midi, false);
      voiceOff(midi);
      addToRecording('off', midi);
    });

    function highlightKey(midi, on) {
      const el = document.querySelector(`[data-midi="${midi}"]`);
      if (!el) return;
      el.classList.toggle('active', on);
    }

    // Volume control
    volume.addEventListener('input', () => {
      if (!audioCtx) return; masterGain.gain.value = parseFloat(volume.value);
    });

    // Octave switch
    octaveSel.addEventListener('change', () => {
      const baseOct = parseInt(octaveSel.value, 10); // 3..5
      startC = 12 * (baseOct + 1); // MIDI Cn = 12*(n+1). C4=60
      buildKeyboard();
    });

    // Sustain checkbox
    sustain.addEventListener('change', () => { if (!sustain.checked) flushSustain(); });

    // ---------- Recording ----------
    let recording = [];
    let isRecording = false;
    let recStart = 0;

    function addToRecording(type, midi) {
      if (!isRecording) return;
      const t = performance.now() - recStart;
      recording.push({ type, midi, t });
    }

    function setRecUI(rec) {
      isRecording = rec;
      recBtn.disabled = rec;
      stopBtn.disabled = !rec;
      playBtn.disabled = rec || recording.length === 0;
      clearBtn.disabled = rec || recording.length === 0;
    }

    recBtn.addEventListener('click', () => {
      getCtx();
      recording = []; recStart = performance.now();
      setRecUI(true);
    });

    stopBtn.addEventListener('click', () => {
      setRecUI(false);
      playBtn.disabled = recording.length === 0;
      clearBtn.disabled = recording.length === 0;
    });

    playBtn.addEventListener('click', () => {
      if (recording.length === 0) return;
      getCtx();
      // Normalize start at 0
      const base = recording[0].t;
      const seq = recording.map(e => ({ ...e, t: e.t - base }));
      // Turn off everything first
      Array.from(activeVoices.keys()).forEach(voiceOff);
      flushSustain();
      // Schedule
      seq.forEach(ev => {
        setTimeout(() => {
          if (ev.type === 'on') { voiceOn(ev.midi, 1); highlightKey(ev.midi, true); }
          else { voiceOff(ev.midi); highlightKey(ev.midi, false); }
        }, ev.t);
      });
    });

    clearBtn.addEventListener('click', () => { recording = []; playBtn.disabled = true; clearBtn.disabled = true; });

    // Build initial keyboard
    buildKeyboard();
  </script>
</body>
</html>
